import { GoogleGenerativeAI } from "@google/generative-ai";
import { Course } from '../types';

export const streamCourseAdvice = async (
  userMessage: string, 
  history: {role: string, text: string}[],
  courses: Course[]
) => {
  const apiKey = process.env.API_KEY;
  
  // Check for missing key or the literal string "undefined" injected by the bundler
  if (!apiKey || apiKey === 'undefined' || apiKey === '"undefined"') {
    console.error("Deepmetrics Error: API_KEY is missing. Please check your Netlify environment variables.");
    throw new Error("Service configuration error: API Key missing. Please ensure API_KEY is set in Netlify Site Settings.");
  }

  // Initialize with the safe key using the @google/generative-ai SDK
  const genAI = new GoogleGenerativeAI(apiKey);
  
  const courseContext = JSON.stringify(courses.map(c => ({
    title: c.title,
    description: c.description,
    level: c.level,
    tags: c.tags,
    price: c.price,
    instructor: c.instructor
  })));

  const systemInstruction = `
    You are an expert Academic Advisor at Deepmetrics Analytics Institute.
    Your goal is to help potential students find the perfect training program for their career goals.
    The currency for all training programs is GHC (Ghanaian Cedi).
    
    Here is our CURRENT Training Program Catalog (prices and details may have changed recently): ${courseContext}
    
    Rules:
    1. Only recommend training programs from the catalog provided above.
    2. Be encouraging, professional, and concise.
    3. If a user asks about pricing, mention the specific price from the catalog in GHC.
    4. If a user is unsure, ask them about their current skill level (Beginner, Intermediate, Advanced).
    5. Keep responses under 100 words unless detailed analysis is requested.
  `;

  try {
    // The history passed typically includes the current user message at the end.
    // For initialization of the Chat history, we generally want previous messages.
    // The sendMessageStream call will send the latest user message.
    const previousHistory = history.slice(0, -1);
    
    // Use gemini-1.5-flash as the standard efficient model
    const model = genAI.getGenerativeModel({ 
        model: 'gemini-1.5-flash',
        systemInstruction: systemInstruction
    });

    const chat = model.startChat({
      history: previousHistory.map(h => ({
        role: h.role === 'model' ? 'model' : 'user',
        parts: [{ text: h.text }]
      })),
      generationConfig: {
        temperature: 0.7,
      }
    });

    const result = await chat.sendMessageStream(userMessage);

    return result.stream;

  } catch (error) {
    console.error("Gemini API Error:", error);
    throw error;
  }
};

export const cleanUpSignatureWithAI = async (base64Image: string): Promise<string> => {
    const apiKey = process.env.API_KEY;
     if (!apiKey || apiKey === 'undefined' || apiKey === '"undefined"') {
        throw new Error("Service configuration error: API Key missing.");
    }
    
    const genAI = new GoogleGenerativeAI(apiKey);
    const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });
    
    // Remove data URL prefix to get raw base64
    const base64Data = base64Image.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, '');

    try {
        const result = await model.generateContent([
            {
                inlineData: {
                    mimeType: 'image/png',
                    data: base64Data
                }
            },
            'Extract and refine this signature. Output ONLY the signature in solid black ink on a pure white background. Remove all noise, paper texture, grid lines, shadows, and artifacts. The result should be a clean, high-contrast signature suitable for a professional certificate.'
        ]);

        const response = await result.response;
        const candidates = response.candidates;
        
        if (candidates && candidates.length > 0) {
            const parts = candidates[0].content.parts;
            for (const part of parts) {
                // Cast to any to access inlineData if returned by specific models
                if ((part as any).inlineData && (part as any).inlineData.data) {
                    return `data:image/png;base64,${(part as any).inlineData.data}`;
                }
            }
        }
        // Fallback or if model returns text instead of image
        throw new Error("No image generated by AI.");
    } catch (error) {
        console.error("AI Signature Cleanup Error:", error);
        throw error;
    }
};